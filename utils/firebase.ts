// utils/firebase.ts
// This file initializes Firebase and provides helper functions to interact with Cloud Firestore.

// Import necessary functions from the Firebase SDK
import { initializeApp } from 'firebase/app';
import {
  getFirestore,           // Function to get the Firestore instance
  collection,             // Function to get a reference to a collection
  onSnapshot,             // Real-time listener for collection/document changes
  addDoc,                 // Function to add a new document to a collection
  updateDoc,              // Function to update an existing document
  deleteDoc,              // Function to delete a document
  query,                  // Function to build a query (e.g., for ordering)
  orderBy,                // Query constraint for ordering documents
  doc                     // Function to get a reference to a specific document
} from 'firebase/firestore';

const localFireBaseConfig = {
  apiKey: "AIzaSyA6m-TPsZdafJe9vvKXKD4Lx4IsvzzHlNI",
  authDomain: "expensetracker-1aae2.firebaseapp.com",
  projectId: "expensetracker-1aae2",
  storageBucket: "expensetracker-1aae2.firebasestorage.app",
  messagingSenderId: "334094229876",
  appId: "1:334094229876:web:abcfb2821e892e9fbb4c21",
  measurementId: "G-TF2G96HJGM"
};

// --- MANDATORY GLOBAL VARIABLES FOR CANVAS ENVIRONMENT ---
// These variables are provided by the Canvas runtime and are crucial
// for correctly initializing Firebase and structuring your Firestore paths.
// DO NOT remove or modify these lines.
// 'default-app-id' is a fallback for local development outside the Canvas environment.
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
// __firebase_config is a JSON string of your Firebase project's config.
// It will be parsed into a JavaScript object.
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : localFireBaseConfig;

// 1. Initialize Firebase App
// This creates and initializes a Firebase app instance using your project configuration.
const app = initializeApp(firebaseConfig);

// 2. Get Firestore Database Instance
// This gets the Firestore database instance associated with your Firebase app.
const db = getFirestore(app);

// --- Data Interface Definition ---
// Define the structure for an 'Expense' document.
// This helps with type safety throughout your application.
export interface Expense {
  id: string;        // Document ID (auto-generated by Firestore)
  name: string;      // e.g., "Groceries", "Dinner out"
  amount: number;    // e.g., 50.75
  category: string;  // e.g., "Food", "Transport", "Entertainment"
  date: string;      // Date of the expense, preferably in "YYYY-MM-DD" format
  currency: string;  // e.g., "USD", "INR"
  notes?: string;    // Optional notes about the expense
  createdAt: Date;   // Timestamp of when the expense was added to Firestore (JS Date object)
}

// --- Firestore Data Access Helper Functions ---

/**
 * Gets a reference to the user's private expenses collection in Firestore.
 * This function constructs the full path: /artifacts/{appId}/users/{userId}/expenses
 * This path adheres to the Canvas environment's security and data isolation requirements.
 *
 * @param userId The authenticated user's unique ID (obtained from Auth.js session).
 * @returns A CollectionReference to the user's expenses.
 * @throws Error if userId is not provided.
 */
const getUserExpensesCollectionRef = (userId: string) => {
  if (!userId) {
    // It's crucial to have a user ID to store data securely for that user.
    console.error("Firestore Error: User ID is required to access user-specific expenses.");
    throw new Error("User ID is required for expense operations.");
  }
  // Construct the full Firestore path for the user's private expense collection.
  return collection(db, `artifacts/${appId}/users/${userId}/expenses`);
};

/**
 * Adds a new expense document to the user's expenses collection.
 *
 * @param userId The authenticated user's unique ID.
 * @param expense An object containing the new expense details (excluding 'id' and 'createdAt').
 */
export const addExpense = async (userId: string, expense: Omit<Expense, 'id' | 'createdAt'>) => {
  try {
    const expensesRef = getUserExpensesCollectionRef(userId);
    // Add a new document. Firestore automatically generates an ID.
    // 'createdAt' is added server-side to ensure accurate timestamps.
    const docRef = await addDoc(expensesRef, {
      ...expense,
      createdAt: new Date(), // Use current Date object; Firestore converts to Timestamp
    });
    console.log("Expense added with ID: ", docRef.id);
  } catch (e) {
    console.error("Error adding expense: ", e);
    // Re-throw the error so calling components can handle it (e.g., display a toast).
    throw e;
  }
};

/**
 * Subscribes to real-time updates of a user's expenses.
 * The callback function is invoked initially and whenever the data changes in Firestore.
 *
 * @param userId The authenticated user's unique ID.
 * @param callback A function that receives the array of fetched expenses.
 * @returns An unsubscribe function to stop listening for updates. Call this in a cleanup effect.
 */
export const subscribeToExpenses = (userId: string, callback: (expenses: Expense[]) => void) => {
  if (!userId) {
    // If no user ID, provide an empty array and a no-op unsubscribe.
    console.warn("Cannot subscribe to expenses: User ID is null or undefined.");
    callback([]);
    return () => {}; // Return a dummy unsubscribe function
  }

  const expensesRef = getUserExpensesCollectionRef(userId);
  // Create a query to order expenses by creation date (newest first).
  // IMPORTANT: For `orderBy`, Firestore might require an index for certain queries.
  // If you get a console warning/error about a missing index, follow the link
  // provided by Firebase to create it in the Console.
  const q = query(expensesRef, orderBy('createdAt', 'desc'));

  // Set up the real-time listener.
  const unsubscribe = onSnapshot(q, (snapshot) => {
    const expenses: Expense[] = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      // Convert Firestore Timestamp objects back to JavaScript Date objects.
      createdAt: doc.data().createdAt?.toDate(),
    })) as Expense[];
    callback(expenses); // Call the provided callback with the updated expenses.
  }, (error) => {
    // Log any errors that occur during the real-time subscription.
    console.error("Error subscribing to expenses: ", error);
  });

  return unsubscribe; // Return the function to stop the subscription.
};

/**
 * Updates an existing expense document.
 *
 * @param userId The authenticated user's unique ID.
 * @param expenseId The ID of the expense document to update.
 * @param updates An object containing the fields to update and their new values.
 */
export const updateExpense = async (userId: string, expenseId: string, updates: Partial<Omit<Expense, 'id' | 'createdAt'>>) => {
  try {
    const expenseDocRef = doc(db, `artifacts/${appId}/users/${userId}/expenses`, expenseId);
    await updateDoc(expenseDocRef, updates);
    console.log("Expense updated: ", expenseId);
  } catch (e) {
    console.error("Error updating expense: ", e);
    throw e;
  }
};

/**
 * Deletes an expense document.
 *
 * @param userId The authenticated user's unique ID.
 * @param expenseId The ID of the expense document to delete.
 */
export const deleteExpense = async (userId: string, expenseId: string) => {
  try {
    const expenseDocRef = doc(db, `artifacts/${appId}/users/${userId}/expenses`, expenseId);
    await deleteDoc(expenseDocRef);
    console.log("Expense deleted: ", expenseId);
  } catch (e) {
    console.error("Error deleting expense: ", e);
    throw e;
  }
};
